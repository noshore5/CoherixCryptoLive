<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Live Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <style>
        body {
            background: #181a20;
            color: #eaecef;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        header {
            background: #22252b;
            padding: 24px 0 16px 0;
            text-align: center;
            box-shadow: 0 2px 8px #0004;
        }
        h1 {
            color: #f0b90b;
            margin: 0;
            font-size: 2.2rem;
        }
        .chart-container {
            width: 90vw;
            max-width: 1200px;
            margin: 40px auto;
            background: #23272f;
            border-radius: 16px;
            box-shadow: 0 4px 24px #0006;
            padding: 32px 24px 24px 24px;
        }
        canvas {
            background: #181a20;
            border-radius: 8px;
        }
        .legend {
            display: flex;
            gap: 24px;
            margin-bottom: 16px;
            align-items: center;
        }
        .legend span {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1rem;
        }
        .legend .btc {
            width: 18px; height: 4px; background: orange; border-radius: 2px;
        }
        .legend .eth {
            width: 18px; height: 4px; background: #3498db; border-radius: 2px;
        }
        a { color: #f0b90b; }
    </style>
</head>
<body>
    <div class="tabs" style="display:flex;gap:2rem;justify-content:center;margin-top:32px;">
        <button id="tab-charts" class="tab-btn active" style="padding:10px 32px;border-radius:8px 8px 0 0;background:#23272f;color:#f0b90b;border:none;font-size:1.1rem;cursor:pointer;">Live Charts</button>
        <button id="tab-other" class="tab-btn" style="padding:10px 32px;border-radius:8px 8px 0 0;background:#181a20;color:#eaecef;border:none;font-size:1.1rem;cursor:pointer;">1 Hour + Detrended</button>
    </div>
    <div id="tab-content-charts">
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Last 3 Hours</h2>
            <div class="legend">
                <span><span class="btc"></span>BTC/USDT</span>
                <span><span class="eth"></span>ETH/USDT</span>
            </div>
            <canvas id="cryptoChart"></canvas>
        </div>
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Last 30 Minutes</h2>
            <div class="legend">
                <span><span class="btc"></span>BTC/USDT</span>
                <span><span class="eth"></span>ETH/USDT</span>
            </div>
            <canvas id="cryptoChart30m"></canvas>
        </div>
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Last 60 Seconds</h2>
            <div class="legend">
                <span><span class="btc"></span>BTC/USDT</span>
                <span><span class="eth"></span>ETH/USDT</span>
            </div>
            <canvas id="cryptoChart60"></canvas>
        </div>
    </div>
    <div id="tab-content-other" style="display:none;">
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Last 1 Hour</h2>
            <div class="legend">
                <span><span class="btc"></span>BTC/USDT</span>
                <span><span class="eth"></span>ETH/USDT</span>
            </div>
            <canvas id="cryptoChart1h"></canvas>
        </div>
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Input Data (Detrended)</h2>
            <div class="legend">
                <span><span class="btc"></span>BTC/USDT</span>
                <span><span class="eth"></span>ETH/USDT</span>
            </div>
            <canvas id="cryptoChart1hDetrended"></canvas>
        </div>
        <div class="chart-container">
            <h2 style="color:#f0b90b;text-align:center;margin-top:0;margin-bottom:12px;font-weight:normal;">Wavelet Coherence (BTC/ETH, Last 1 Hour)</h2>
            <canvas id="waveletCoherenceChart" style="max-width:100%;max-height:400px;display:block;margin:0 auto;background:#181a20;"></canvas>
            <div id="coherenceColorbar" style="width:100%;margin-top:8px;text-align:center;"></div>
        </div>
    </div>
    <script>
// Tab switching logic
document.addEventListener('DOMContentLoaded', function() {
    const tabCharts = document.getElementById('tab-charts');
    const tabOther = document.getElementById('tab-other');
    const contentCharts = document.getElementById('tab-content-charts');
    const contentOther = document.getElementById('tab-content-other');
    tabCharts.addEventListener('click', function() {
        tabCharts.classList.add('active');
        tabOther.classList.remove('active');
        contentCharts.style.display = '';
        contentOther.style.display = 'none';
    });
    tabOther.addEventListener('click', function() {
        tabOther.classList.add('active');
        tabCharts.classList.remove('active');
        contentCharts.style.display = 'none';
        contentOther.style.display = '';
    });
});
let cryptoChart;
let cryptoChart30m;
let cryptoChart60;
let cryptoChart1h;
let cryptoChart1hDetrended;
function sliceLast1h(data) {
    return data.slice(-3600);
}

// Linear detrend (remove best-fit line)
function detrend(data) {
    if (data.length < 2) return data.map(() => 0);
    // Least squares linear fit
    const n = data.length;
    const x = Array.from({length: n}, (_, i) => i);
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = data.reduce((a, b) => a + b, 0);
    const sumXX = x.reduce((a, b) => a + b * b, 0);
    const sumXY = x.reduce((a, b, i) => a + b * data[i], 0);
    const denom = n * sumXX - sumX * sumX;
    if (denom === 0) return data.slice();
    const slope = (n * sumXY - sumX * sumY) / denom;
    const intercept = (sumY - slope * sumX) / n;
    return data.map((y, i) => y - (slope * i + intercept));
}
async function updateChart1h() {
    let [btc, eth] = await Promise.all([
        fetchData('BTCUSDT'),
        fetchData('ETHUSDT')
    ]);
    if (!Array.isArray(btc) || btc.length === 0) btc = lastBTC;
    if (!Array.isArray(eth) || eth.length === 0) eth = lastETH;
    const btc1hArr = sliceLast1h(btc);
    const eth1hArr = sliceLast1h(eth);
    const btcData = formatData(btc1hArr);
    const ethData = formatData(eth1hArr);
    // Detrend
    const btcDetrended = detrend(btcData.prices);
    const ethDetrended = detrend(ethData.prices);
    // Main 1h chart
    if (cryptoChart1h) {
        // Smooth y-axis min/max for 1h chart
        let minY = Math.min(...btcData.prices, ...ethData.prices);
        let maxY = Math.max(...btcData.prices, ...ethData.prices);
        if (cryptoChart1h.options.scales.y._lastMin !== undefined) {
            minY = cryptoChart1h.options.scales.y._lastMin + (minY - cryptoChart1h.options.scales.y._lastMin) * SMOOTH_FACTOR;
            maxY = cryptoChart1h.options.scales.y._lastMax + (maxY - cryptoChart1h.options.scales.y._lastMax) * SMOOTH_FACTOR;
        }
        cryptoChart1h.options.scales.y._lastMin = minY;
        cryptoChart1h.options.scales.y._lastMax = maxY;
        cryptoChart1h.options.scales.y.min = minY;
        cryptoChart1h.options.scales.y.max = maxY;
        cryptoChart1h.data.labels = btcData.labels;
        cryptoChart1h.data.datasets[0].data = btcData.prices;
        cryptoChart1h.data.datasets[1].data = ethData.prices;
        cryptoChart1h.update('active'); // Animate y-ticks
    }
    // Detrended chart
    if (cryptoChart1hDetrended) {
        // Smooth y-axis min/max for 1h detrended chart
        let minY = Math.min(...btcDetrended, ...ethDetrended);
        let maxY = Math.max(...btcDetrended, ...ethDetrended);
        if (cryptoChart1hDetrended.options.scales.y._lastMin !== undefined) {
            minY = cryptoChart1hDetrended.options.scales.y._lastMin + (minY - cryptoChart1hDetrended.options.scales.y._lastMin) * SMOOTH_FACTOR;
            maxY = cryptoChart1hDetrended.options.scales.y._lastMax + (maxY - cryptoChart1hDetrended.options.scales.y._lastMax) * SMOOTH_FACTOR;
        }
        cryptoChart1hDetrended.options.scales.y._lastMin = minY;
        cryptoChart1hDetrended.options.scales.y._lastMax = maxY;
        cryptoChart1hDetrended.options.scales.y.min = minY;
        cryptoChart1hDetrended.options.scales.y.max = maxY;
        cryptoChart1hDetrended.data.labels = btcData.labels;
        cryptoChart1hDetrended.data.datasets[0].data = btcDetrended;
        cryptoChart1hDetrended.data.datasets[1].data = ethDetrended;
        cryptoChart1hDetrended.update('active'); // Animate y-ticks
    }
}
let lastBTC = [];
let lastETH = [];
let lastBTCData = null;
let lastETHData = null;
let lastBTC30m = null;
let lastETH30m = null;
let lastBTC60 = null;
let lastETH60 = null;
let btcBase = null;
let ethBase = null;
let btcBase30m = null;
let ethBase30m = null;
let btcBase60 = null;
let ethBase60 = null;
const SMOOTH_FACTOR = 0.3; // 0 = no smoothing, 1 = instant jump
        async function fetchData(symbol) {
            try {
                const res = await fetch(`/api/ohlcv/${symbol}`);
                if (!res.ok) {
                    console.error(`Error fetching data for ${symbol}: HTTP ${res.status}`);
                    return [];
                }
                const data = await res.json();
                if (Array.isArray(data) && data.length > 0) {
                    console.log(`Fetched data for ${symbol}:`, data.length, 'points');
                } else {
                    console.error(`No data fetched for ${symbol}`);
                }
                return data;
            } catch (err) {
                console.error(`Error fetching data for ${symbol}:`, err);
                return [];
            }
        }
function formatData(data) {
    const closes = data.map(d => parseFloat(d.close));
    const normBase = closes[0] || 1;
    let labels = data.map(d => new Date(d.timestamp));
    let prices = closes.map(v => ((v - normBase) / normBase) * 100);
    return {
        labels,
        prices,
        base: normBase
    };
}
function createChart(ctx, btcData, ethData, is60s = false) {
    return new Chart(ctx, {
        type: 'line',
        data: {
            labels: btcData.labels,
            datasets: [
                {
                    label: 'BTC/USDT (% change)',
                    data: btcData.prices,
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255,165,0,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                },
                {
                    label: 'ETH/USDT (% change)',
                    data: ethData.prices,
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52,152,219,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                }
            ]
        },
        options: {
            animation: {
                duration: 1200,
                easing: 'easeInOutCubic',
                animateScale: true,
                animateRotate: true,
            },
            transitions: {
                show: { animations: { x: {duration: 1200}, y: {duration: 1200} } },
                hide: { animations: { x: {duration: 1200}, y: {duration: 1200} } }
            },
            plugins: {
                legend: {
                    labels: {
                        color: '#eaecef',
                        font: { size: 16 }
                    }
                },
                tooltip: {
                    backgroundColor: '#23272f',
                    titleColor: '#f0b90b',
                    bodyColor: '#eaecef',
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: is60s
                        ? { unit: 'second', displayFormats: { second: 'HH:mm:ss' }, tooltipFormat: 'HH:mm:ss' }
                        : { unit: 'minute', displayFormats: { minute: 'HH:mm' }, tooltipFormat: 'HH:mm' },
                    ticks: {
                        color: '#eaecef',
                        autoSkip: true,
                        maxTicksLimit: is60s ? 10 : 12,
                        callback: function(value, index, values) {
                            if (index === 0) {
                                return is60s ? 'Time (HH:mm:ss)' : 'Time (HH:mm)';
                            }
                            return this.getLabelForValue(value);
                        }
                    },
                    grid: { color: '#23272f' }
                },
                y: {
                    beginAtZero: false,
                    min: undefined,
                    max: undefined,
                    ticks: {
                        color: '#eaecef',
                        callback: function(value) { return value.toFixed(2) + '%'; },
                        autoSkip: false
                    },
                    grid: { color: '#23272f' }
                }
            }
        }
    });
}
function sliceLast30m(data) {
    return data.slice(-1800);
}

function sliceLast60(data) {
    // Get only the last 60 seconds (assuming 1s resolution)
    return data.slice(-60);
}


function lerpArray(oldArr, newArr, factor) {
    if (!oldArr || oldArr.length !== newArr.length) return newArr;
    return newArr.map((v, i) => oldArr[i] + (v - oldArr[i]) * factor);
}
function lerpDateArray(oldArr, newArr, factor) {
    if (!oldArr || !Array.isArray(oldArr) || !Array.isArray(newArr)) return newArr;
    // Pad arrays to same length for smooth transition
    const maxLen = Math.max(oldArr.length, newArr.length);
    const padOld = oldArr.length < maxLen ? [ ...Array(maxLen - oldArr.length).fill(newArr[0]), ...oldArr ] : oldArr;
    const padNew = newArr.length < maxLen ? [ ...Array(maxLen - newArr.length).fill(oldArr[0]), ...newArr ] : newArr;
    return padOld.map((v, i) => new Date(v.getTime() + (padNew[i].getTime() - v.getTime()) * factor));
}

async function updateChart() {
    let [btc, eth] = await Promise.all([
        fetchData('BTCUSDT'),
        fetchData('ETHUSDT')
    ]);
    // If no data, use last known
    if (!Array.isArray(btc) || btc.length === 0) btc = lastBTC;
    else lastBTC = btc;
    if (!Array.isArray(eth) || eth.length === 0) eth = lastETH;
    else lastETH = eth;
    // --- 3h chart ---
    const btcData = formatData(btc);
    const ethData = formatData(eth);
    if (lastBTCData && lastBTCData.labels && btcData.labels) {
        btcData.prices = (lastBTCData.prices && lastBTCData.prices.length === btcData.prices.length)
            ? lerpArray(lastBTCData.prices, btcData.prices, SMOOTH_FACTOR)
            : btcData.prices;
        ethData.prices = (lastETHData.prices && lastETHData.prices.length === ethData.prices.length)
            ? lerpArray(lastETHData.prices, ethData.prices, SMOOTH_FACTOR)
            : ethData.prices;
        btcData.labels = lerpDateArray(lastBTCData.labels, btcData.labels, SMOOTH_FACTOR);
        ethData.labels = lerpDateArray(lastETHData.labels, ethData.labels, SMOOTH_FACTOR);
    }
    // Always set y-axis to full data range
    let minY = Math.min(...btcData.prices, ...ethData.prices);
    let maxY = Math.max(...btcData.prices, ...ethData.prices);
    cryptoChart.options.scales.y.min = minY;
    cryptoChart.options.scales.y.max = maxY;
    cryptoChart.data.labels = btcData.labels;
    cryptoChart.data.datasets[0].data = btcData.prices;
    cryptoChart.data.datasets[1].data = ethData.prices;
    cryptoChart.update();
    lastBTCData = btcData;
    lastETHData = ethData;
    // --- 30m chart ---
    const btc30mArr = sliceLast30m(btc);
    const eth30mArr = sliceLast30m(eth);
    const btc30m = formatData(btc30mArr);
    const eth30m = formatData(eth30mArr);
    if (lastBTC30m && lastBTC30m.labels && btc30m.labels) {
        btc30m.prices = (lastBTC30m.prices && lastBTC30m.prices.length === btc30m.prices.length)
            ? lerpArray(lastBTC30m.prices, btc30m.prices, SMOOTH_FACTOR)
            : btc30m.prices;
        eth30m.prices = (lastETH30m.prices && lastETH30m.prices.length === eth30m.prices.length)
            ? lerpArray(lastETH30m.prices, eth30m.prices, SMOOTH_FACTOR)
            : eth30m.prices;
        btc30m.labels = lerpDateArray(lastBTC30m.labels, btc30m.labels, SMOOTH_FACTOR);
        eth30m.labels = lerpDateArray(lastETH30m.labels, eth30m.labels, SMOOTH_FACTOR);
    }
    let minY30 = Math.min(...btc30m.prices, ...eth30m.prices);
    let maxY30 = Math.max(...btc30m.prices, ...eth30m.prices);
    if (cryptoChart30m.options.scales.y._lastMin !== undefined) {
        minY30 = cryptoChart30m.options.scales.y._lastMin + (minY30 - cryptoChart30m.options.scales.y._lastMin) * SMOOTH_FACTOR;
        maxY30 = cryptoChart30m.options.scales.y._lastMax + (maxY30 - cryptoChart30m.options.scales.y._lastMax) * SMOOTH_FACTOR;
    }
    cryptoChart30m.options.scales.y._lastMin = minY30;
    cryptoChart30m.options.scales.y._lastMax = maxY30;
    cryptoChart30m.options.scales.y.min = minY30;
    cryptoChart30m.options.scales.y.max = maxY30;
    cryptoChart30m.data.labels = btc30m.labels;
    cryptoChart30m.data.datasets[0].data = btc30m.prices;
    cryptoChart30m.data.datasets[1].data = eth30m.prices;
    cryptoChart30m.update();
    lastBTC30m = btc30m;
    lastETH30m = eth30m;
    // --- 60s chart ---
    const btc60 = formatData(sliceLast60(btc));
    const eth60 = formatData(sliceLast60(eth));
    if (lastBTC60 && lastBTC60.labels && btc60.labels) {
        btc60.prices = (lastBTC60.prices && lastBTC60.prices.length === btc60.prices.length)
            ? lerpArray(lastBTC60.prices, btc60.prices, SMOOTH_FACTOR)
            : btc60.prices;
        eth60.prices = (lastETH60.prices && lastETH60.prices.length === eth60.prices.length)
            ? lerpArray(lastETH60.prices, eth60.prices, SMOOTH_FACTOR)
            : eth60.prices;
        btc60.labels = lerpDateArray(lastBTC60.labels, btc60.labels, SMOOTH_FACTOR);
        eth60.labels = lerpDateArray(lastETH60.labels, eth60.labels, SMOOTH_FACTOR);
    }
    let minY60 = Math.min(...btc60.prices, ...eth60.prices);
    let maxY60 = Math.max(...btc60.prices, ...eth60.prices);
    if (cryptoChart60.options.scales.y._lastMin !== undefined) {
        minY60 = cryptoChart60.options.scales.y._lastMin + (minY60 - cryptoChart60.options.scales.y._lastMin) * SMOOTH_FACTOR;
        maxY60 = cryptoChart60.options.scales.y._lastMax + (maxY60 - cryptoChart60.options.scales.y._lastMax) * SMOOTH_FACTOR;
    }
    cryptoChart60.options.scales.y._lastMin = minY60;
    cryptoChart60.options.scales.y._lastMax = maxY60;
    cryptoChart60.options.scales.y.min = minY60;
    cryptoChart60.options.scales.y.max = maxY60;
    cryptoChart60.data.labels = btc60.labels;
    cryptoChart60.data.datasets[0].data = btc60.prices;
    cryptoChart60.data.datasets[1].data = eth60.prices;
    cryptoChart60.update();
    lastBTC60 = btc60;
    lastETH60 = eth60;
}

window.onload = async function() {
    let [btc, eth] = await Promise.all([
        fetchData('BTCUSDT'),
        fetchData('ETHUSDT')
    ]);
    // If no data, use empty arrays
    if (!Array.isArray(btc) || btc.length === 0) btc = [];
    else lastBTC = btc;
    if (!Array.isArray(eth) || eth.length === 0) eth = [];
    else lastETH = eth;
    // Set initial bases for normalization (per session, per chart)
    // Create charts
    const btc30mArr = sliceLast30m(btc);
    const eth30mArr = sliceLast30m(eth);
    const btc60Arr = sliceLast60(btc);
    const eth60Arr = sliceLast60(eth);
    const btcData = formatData(btc);
    const ethData = formatData(eth);
    cryptoChart = createChart(document.getElementById('cryptoChart').getContext('2d'), btcData, ethData, false);
    const btc30m = formatData(btc30mArr);
    const eth30m = formatData(eth30mArr);
    cryptoChart30m = createChart(document.getElementById('cryptoChart30m').getContext('2d'), btc30m, eth30m, false);
    const btc60 = formatData(btc60Arr);
    const eth60 = formatData(eth60Arr);
    cryptoChart60 = createChart(document.getElementById('cryptoChart60').getContext('2d'), btc60, eth60, true);
    // 1h charts for tab 2
    const btc1hArr = sliceLast1h(btc);
    const eth1hArr = sliceLast1h(eth);
    const btc1h = formatData(btc1hArr);
    const eth1h = formatData(eth1hArr);
    // 1h chart with no hover circles
    cryptoChart1h = new Chart(document.getElementById('cryptoChart1h').getContext('2d'), {
        type: 'line',
        data: {
            labels: btc1h.labels,
            datasets: [
                {
                    label: 'BTC/USDT (% change)',
                    data: btc1h.prices,
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255,165,0,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                },
                {
                    label: 'ETH/USDT (% change)',
                    data: eth1h.prices,
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52,152,219,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                }
            ]
        },
        options: {
            animation: {
                duration: 1200,
                easing: 'easeInOutCubic',
                animateScale: true,
                animateRotate: true,
            },
            transitions: {
                show: { animations: { x: {duration: 1200}, y: {duration: 1200} } },
                hide: { animations: { x: {duration: 1200}, y: {duration: 1200} } }
            },
            plugins: {
                legend: {
                    labels: {
                        color: '#eaecef',
                        font: { size: 16 }
                    }
                },
                tooltip: {
                    backgroundColor: '#23272f',
                    titleColor: '#f0b90b',
                    bodyColor: '#eaecef',
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'minute', displayFormats: { minute: 'HH:mm' }, tooltipFormat: 'HH:mm' },
                    ticks: {
                        color: '#eaecef',
                        autoSkip: true,
                        maxTicksLimit: 12,
                        callback: function(value, index, values) {
                            if (index === 0) {
                                return 'Time (HH:mm)';
                            }
                            return this.getLabelForValue(value);
                        }
                    },
                    grid: { color: '#23272f' }
                },
                y: {
                    beginAtZero: false,
                    min: undefined,
                    max: undefined,
                    ticks: {
                        color: '#eaecef',
                        callback: function(value) { return value.toFixed(2) + '%'; },
                        autoSkip: false
                    },
                    grid: { color: '#23272f' }
                }
            }
        }
    });
    // Detrended 1h chart with no hover circles
    const btcDetrended = detrend(btc1h.prices);
    const ethDetrended = detrend(eth1h.prices);
    cryptoChart1hDetrended = new Chart(document.getElementById('cryptoChart1hDetrended').getContext('2d'), {
        type: 'line',
        data: {
            labels: btc1h.labels,
            datasets: [
                {
                    label: 'BTC/USDT (% change)',
                    data: btcDetrended,
                    borderColor: 'orange',
                    backgroundColor: 'rgba(255,165,0,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                },
                {
                    label: 'ETH/USDT (% change)',
                    data: ethDetrended,
                    borderColor: '#3498db',
                    backgroundColor: 'rgba(52,152,219,0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    tension: 0.1
                }
            ]
        },
        options: {
            animation: {
                duration: 1200,
                easing: 'easeInOutCubic',
                animateScale: true,
                animateRotate: true,
            },
            transitions: {
                show: { animations: { x: {duration: 1200}, y: {duration: 1200} } },
                hide: { animations: { x: {duration: 1200}, y: {duration: 1200} } }
            },
            plugins: {
                legend: {
                    labels: {
                        color: '#eaecef',
                        font: { size: 16 }
                    }
                },
                tooltip: {
                    backgroundColor: '#23272f',
                    titleColor: '#f0b90b',
                    bodyColor: '#eaecef',
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'minute', displayFormats: { minute: 'HH:mm' }, tooltipFormat: 'HH:mm' },
                    ticks: {
                        color: '#eaecef',
                        autoSkip: true,
                        maxTicksLimit: 12,
                        callback: function(value, index, values) {
                            if (index === 0) {
                                return 'Time (HH:mm)';
                            }
                            return this.getLabelForValue(value);
                        }
                    },
                    grid: { color: '#23272f' }
                },
                y: {
                    beginAtZero: false,
                    min: undefined,
                    max: undefined,
                    ticks: {
                        color: '#eaecef',
                        callback: function(value) { return value.toFixed(2) + '%'; },
                        autoSkip: false
                    },
                    grid: { color: '#23272f' }
                }
            }
        }
    });

    // --- Auto-update all charts every 3s ---
    setInterval(updateChart, 3000);
    setInterval(updateChart1h, 3000);

    // --- Auto-update coherence plot every 3s using Chart.js matrix chart ---
    let waveletCoherenceChart = null;
    function viridisColor(val) {
        var stops = [
            [68,1,84],[71,44,122],[59,81,139],[44,113,142],[33,144,141],
            [39,173,129],[92,200,99],[170,220,50],[253,231,37]
        ];
        var idx = Math.max(0, Math.min(stops.length-2, Math.floor(val*(stops.length-1))));
        var t = val*(stops.length-1)-idx;
        var c0 = stops[idx], c1 = stops[idx+1];
        var r = Math.round(c0[0]+(c1[0]-c0[0])*t);
        var g = Math.round(c0[1]+(c1[1]-c0[1])*t);
        var b = Math.round(c0[2]+(c1[2]-c0[2])*t);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }
    function fetchAndPlotCoherence() {
        fetch('/api/wavelet_coherence')
            .then(function(res) {
                if (!res.ok) throw new Error('Failed to fetch wavelet coherence');
                return res.json();
            })
            .then(function(data) {
                var coherence = data.coherence;
                var freqs = data.freqs;
                if (!Array.isArray(coherence) || !Array.isArray(freqs)) return;
                if (!window.ChartMatrixRegistered) {
                    var script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@4.1.0/dist/chartjs-chart-matrix.umd.min.js';
                    script.onload = function() { window.ChartMatrixRegistered = true; fetchAndPlotCoherence(); };
                    document.head.appendChild(script);
                    return;
                }
                var matrixData = [];
                var nFreq = freqs.length;
                var nTime = coherence[0].length;
                for (var i = 0; i < nFreq; ++i) {
                    for (var j = 0; j < nTime; ++j) {
                        matrixData.push({
                            x: j,
                            y: nFreq - 1 - i,
                            v: coherence[i][j]
                        });
                    }
                }
                if (waveletCoherenceChart) waveletCoherenceChart.destroy();
                var ctx = document.getElementById('waveletCoherenceChart').getContext('2d');
                waveletCoherenceChart = new Chart(ctx, {
                    type: 'matrix',
                    data: {
                        datasets: [{
                            label: 'Wavelet Coherence',
                            data: matrixData,
                            backgroundColor: function(ctx) { return viridisColor(ctx.raw.v); },
                            width: function(obj) { return obj.chart.chartArea ? obj.chart.chartArea.width / nTime : 4; },
                            height: function(obj) { return obj.chart.chartArea ? obj.chart.chartArea.height / nFreq : 4; },
                            borderWidth: 0
                        }]
                    },
                    options: {
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: function() { return ''; },
                                    label: function(ctx) { return 'Coherence: ' + ctx.raw.v.toFixed(2) + '\nPeriod: ' + (1/freqs[nFreq-1-ctx.raw.y]).toFixed(2) + 's'; }
                                },
                                backgroundColor: '#23272f',
                                bodyColor: '#eaecef',
                            }
                        },
                        scales: {
                            x: {
                                display: false,
                                min: 0,
                                max: nTime-1
                            },
                            y: {
                                display: true,
                                min: 0,
                                max: nFreq-1,
                                ticks: {
                                    color: '#eaecef',
                                    callback: function(v) { return (1/freqs[nFreq-1-v]).toFixed(2)+'s'; },
                                    maxTicksLimit: 8
                                },
                                grid: { color: '#23272f' }
                            }
                        }
                    }
                });
                var colorbar = document.getElementById('coherenceColorbar');
                colorbar.innerHTML = '';
                var bar = document.createElement('canvas');
                bar.width = 300; bar.height = 24;
                colorbar.appendChild(bar);
                var bctx = bar.getContext('2d');
                for (var i = 0; i < 300; ++i) {
                    bctx.fillStyle = viridisColor(i/299);
                    bctx.fillRect(i,0,1,24);
                }
                bctx.font = '14px Arial';
                bctx.fillStyle = '#eaecef';
                bctx.fillText('0',0,20);
                bctx.fillText('1',290,20);
                bctx.fillText('Coherence',120,12);
            })
            .catch(function(err) {
                console.error('Wavelet coherence fetch/plot error:', err);
            });
    }
    fetchAndPlotCoherence();
    setInterval(fetchAndPlotCoherence, 3000);
};
    </script>
</body>
</html>
